#################################################################################################################################################
#################################################################################################################################################
#####################################
#####################################          Bash Aliases.   Feike Li     2020.5.2 ver
#####################################          write some documentation formatting here:
#####################################
#####################################	         1.temp aliases
#####################################          2.system aliases
#####################################	         3.applications
#####################################
#####################################
#################################################################################################################################################
#################################################################################################################################################


#=======================================================================
#  TEMP & MISC LAUNCHERS
#=======================================================================
# Temporary aliases and launchers for specific applications.
alias t3='npm create t3-app@latest'
alias e='neomutt'

#=======================================================================
#  CORE SYSTEM & NAVIGATION
#=======================================================================
# Basic aliases for shell navigation, editing config files, and system commands.
alias v='nvim'
alias vv='nvim .'
alias cc='claude --chrome'
alias r='yazi'
alias f='tmux a' 
alias c='clear'
alias h='cd $HOME && clear'
alias q='exit'
alias s='cdf'
alias ss='cdf && yazi'
alias clear='clear && tmux clear-history'
alias ls='ls -lAhvFis --color=always --group-directories-first --time-style="+%Y-%m-%d %H:%M"'
alias top='btop'
alias t='btop'
p() { if [ $# -eq 0 ]; then echo "usage: p <command>"; return 1; fi; unbuffer "$@" 2>&1 | less -RiFS --use-color --color=Sky; }
alias tree='tree -a'
alias process='ps -ef | grep'
alias biggestFile='find . -type f -exec du -h {} + | sort -hr | head -20'
alias du='du -h '
alias cal='ncal -b -3'
alias neofetch='fastfetch'


#=======================================================================
#  CONFIGURATION & EDITING SHORTCUTS
#=======================================================================
# Quick access to edit configuration files and other specific text files.
alias password='nvim ~/Documents/feeco/1.lifeike/password.txt'
alias config='cd ~/.config && yazi'
alias vali='nvim ~/.aliases'
alias vbash='nvim ~/.bashrc'
alias vhistory='nvim ~/.bash_history'
alias o='nvim ~/Desktop/text.txt'


#=======================================================================
#  DIRECTORY SHORTCUTS
#=======================================================================
# Quick navigation to frequently used directories.
alias d='cd /home/feeco/Downloads && yazi'
repos() {
    local dir
    dir=$(find ~/Documents -maxdepth 3 -name .git -type d 2>/dev/null | sed 's|/.git$||' | fzf --height=40% --reverse --prompt='Repo> ')
    if [[ -n "$dir" ]]; then
        cd "$dir"
    else
        cd ~/Documents && yazi
    fi
}
alias desktop='cd /home/feeco/Desktop && yazi'
alias video='cd /home/feeco/Videos && yazi'
alias picture='cd /home/feeco/Pictures && yazi'
alias music='yt '


#=======================================================================
#  SEARCH, HISTORY & BOOKMARKS
#=======================================================================
# Fuzzy search for files, history, and marked directories.
cdf() {
   cd ~
   local file
   local dir
   file=$(fzf +m -q "$1") && dir=$(dirname "$file") 
   cd "$dir"
   pwd
}

# find available commands from .bashrc .alias and command history
alias lc='eval $(fh)'
fh() {
  set -o history
  HISTFILE=~/.bash_history
  local cmd

  # STAGE 1: Search Aliases and Functions
  cmd=$( (alias; declare -F | cut -d' ' -f3) | 
         fzf --height=40% --border --prompt='Alias/Func> ' \
             --header='Searching Aliases & Functions (ESC to search History)' \
             --bind='tab:down,shift-tab:up' --select-1 --exit-0)

  # STAGE 2: If nothing found in Stage 1, search History
  if [[ -z "$cmd" ]]; then
    cmd=$(history | tac | sed 's/^[[:space:]]*[0-9]\+[[:space:]]*//' | awk '!seen[$0]++' | 
          fzf --height=80% --border --prompt='History> ' \
              --bind='tab:down,shift-tab:up')
  fi

  # Execution logic
  if [[ -n "$cmd" ]]; then
    # If it was an alias, clean the 'alias ' prefix and '=...' suffix to get the name
    if [[ "$cmd" == alias* ]]; then
      cmd=$(echo "$cmd" | sed "s/^alias //; s/='.*$//")
    fi
    echo "$cmd"
  fi
}

# mark current directory as marked list
mm() {
    echo "$PWD" >> "$HOME/.marked_directories"
    echo "Marked: $PWD"
}

# search marked list with fzf
lm() {
    if [[ ! -f "$HOME/.marked_directories" ]]; then
        echo "No directories marked yet."
        return 1
    fi
    local dir
    dir=$(cat "$HOME/.marked_directories" | fzf)
    [[ -n "$dir" ]] && cd "$dir" && echo "Changed directory to: $dir"
}


#=======================================================================
#  NETWORKING
#=======================================================================
# Functions and aliases for managing Wi-Fi and inspecting network ports.
alias wifilist='nmcli device wifi list'
show_connected_wifi(){
    nmcli connection show
}

delete_connected_wifi(){
    read -r -p "Enter SSID: " ssid
    nmcli connection delete "$ssid"
}

connect_wifi() {
    read -r -p "Enter SSID: " ssid
    read -r -s -p "Enter Password: " password
    echo 
    sudo nmcli device wifi connect "$ssid" password "$password"
}

port() {
    local search_term="${1:-}"
    local GREEN='\033[0;32m'
    local BLUE='\033[0;34m'
    local YELLOW='\033[1;33m'
    local CYAN='\033[1;36m'
    local NC='\033[0m'
    
    echo -e "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo -e "â•‘                        NETWORK PORTS & CONNECTIONS                         â•‘"
    echo -e "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
    printf "%-10s %-25s %-10s %-15s %-12s %s\n" "PROTO" "LOCAL ADDRESS" "PORT" "STATE" "PID" "PROGRAM"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    sudo netstat -tulpn 2>/dev/null | grep -v "^Active\|^Proto" | while read -r line; do
        [ -z "$line" ] && continue
        proto=$(echo "$line" | awk '{print $1}')
        local_addr=$(echo "$line" | awk '{print $4}')
        
        if [[ $proto == udp* ]]; then
            state="-"
            pid_program=$(echo "$line" | awk '{print $6}')
        else
            state=$(echo "$line" | awk '{print $6}')
            pid_program=$(echo "$line" | awk '{print $7}')
        fi
        
        if [[ $local_addr == *":"* ]]; then
            ip=$(echo "$local_addr" | rev | cut -d: -f2- | rev)
            port=$(echo "$local_addr" | rev | cut -d: -f1 | rev)
        else
            ip="N/A"
            port="N/A"
        fi
        
        if [[ $pid_program == *"/"* ]]; then
            pid=$(echo "$pid_program" | cut -d/ -f1)
            program=$(echo "$pid_program" | cut -d/ -f2-)
        elif [[ $pid_program == "-" ]]; then
            pid="-"
            program="-"
        else
            pid="${pid_program:-N/A}"
            program="N/A"
        fi
        
        [ -n "$search_term" ] && ! echo "$line $program $port" | grep -qi "$search_term" && continue
        
        case $proto in
            tcp*) proto_colored="${GREEN}${proto}${NC}" ;;
            udp*) proto_colored="${BLUE}${proto}${NC}" ;;
            *) proto_colored="$proto" ;;
        esac
        
        case $state in
            LISTEN) state_colored="${YELLOW}${state}${NC}" ;;
            ESTABLISHED) state_colored="${GREEN}${state}${NC}" ;;
            *) state_colored="$state" ;;
        esac
        
        port_colored="${CYAN}${port}${NC}"
        
        printf "%-10s %-25s %-10s %-15s %-12s %s\n" "$proto" "$ip" "$port" "$state" "$pid" "$program" | \
        sed -E "s/^(tcp[^ ]*)/$(echo -e ${GREEN})\1$(echo -e ${NC})/" | \
        sed -E "s/^(udp[^ ]*)/$(echo -e ${BLUE})\1$(echo -e ${NC})/" | \
        sed -E "s/([0-9]+)( +LISTEN)/$(echo -e ${CYAN})\1$(echo -e ${NC})\2/" | \
        sed -E "s/([0-9]+)( +-)/$(echo -e ${CYAN})\1$(echo -e ${NC})\2/" | \
        sed -E "s/LISTEN/$(echo -e ${YELLOW})LISTEN$(echo -e ${NC})/" | \
        sed -E "s/ESTABLISHED/$(echo -e ${GREEN})ESTABLISHED$(echo -e ${NC})/"
    done
    
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo -e "\nğŸ’¡ Usage: port [search_term] | Examples: port nginx | ports 80\n"
}

portlistening() {
    local CYAN='\033[1;36m'
    local GREEN='\033[0;32m'
    local NC='\033[0m'
    
    echo -e "\nğŸ”Š LISTENING PORTS\n"
    printf "%-10s %-12s %-25s\n" "PROTO" "PORT" "PROGRAM"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    sudo netstat -tulpn 2>/dev/null | grep LISTEN | awk '{print $1, $4, $7}' | \
    while read proto addr pidprog; do
        port=$(echo "$addr" | rev | cut -d: -f1 | rev)
        prog=$(echo "$pidprog" | cut -d/ -f2-)
        printf "%-10s %-12s %-25s\n" "$proto" "$port" "$prog"
    done | sort -k2 -n | while IFS= read -r line; do
        echo "$line" | sed -E "s/^(tcp[^ ]*)/\\$(echo -e '\033[0;32m')\1\\$(echo -e '\033[0m')/" | \
        sed -E "s/([0-9]+)/\\$(echo -e '\033[1;36m')\1\\$(echo -e '\033[0m')/"
    done
    echo ""
}

look() {
    if [ $# -eq 0 ]; then
        echo "Please provide a domain name."
        return 1
    fi
    local domain="$1"
    whois "$domain" | \
    awk '/Creation Date/ {print "\033[31m" $0 "\033[0m"} {print}' | \
    less -R
}


#=======================================================================
#  HARDWARE & DISPLAY
#=======================================================================
# Control screen brightness, rotation, and audio volume.
alias d1='xrandr --output DP-2 --brightness 0.5'
alias d2='xrandr --output DP-2 --brightness 0.7'
alias d3='xrandr --output DP-2 --brightness 0.9'
alias d4='xrandr --output DP-2 --brightness 1.1'

alias l1='xrandr --output eDP --brightness 0.5'
alias l2='xrandr --output eDP --brightness 0.8'
alias l3='xrandr --output eDP --brightness 1'

alias secondMonitorRotation='xrandr --output DP-1 --rotate left'
alias volume='alsamixer'


#=======================================================================
#  FILE & TEXT MANIPULATION
#=======================================================================
# Aliases and functions for file conversion, extraction, and formatting.
alias unrarall='for file in *.rar; do unrar e -p "$file"; done'
alias unzipgarbled='unzip -O cp936 '
alias convertallpdf='ls *.pdf | xargs -n1 pdftotext'
alias convertallpdftopng=allpdftopng
function allpdftopng(){
	for file in *.pdf;
		do pdftoppm "$file" "$file";
	done
}
alias convertpptxtopdf='libreoffice --headless --invisible --convert-to pdf *.pptx'
alias convertdocxtotxt='libreoffice --headless --convert-to txt'
alias convertjpgtopdf='convert *.jpg output.pdf'
md2pdf_batch() {
    local tmp_css="__temp_style.css"
    cat > "$tmp_css" <<'EOF'
body { margin: 5mm; font-family: sans-serif; }
pre { background-color: #eaeaea; color: #000000; padding: 10px; border-radius: 4px; overflow-x: auto; border: 1px solid #cccccc; }
code { font-family: monospace; }
code span.kw { font-weight: bold; }
code span.st { font-style: italic; }
code span.co { color: #555555; }
code span.fu { text-decoration: underline; }
h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
table { border-collapse: collapse; }
table, th, td { border: 1px solid #ccc; padding: 4px; }
EOF

    for f in *.md; do
        [[ -f "$f" ]] || continue
        echo "Converting $f â†’ ${f%.md}.pdf"
        pandoc "$f" -o "${f%.md}.pdf" \
            --pdf-engine=wkhtmltopdf \
            -V margin-top=5mm \
            -V margin-bottom=5mm \
            -V margin-left=5mm \
            -V margin-right=5mm \
            --css="$tmp_css" \
            --pdf-engine-opt=--enable-local-file-access
    done
    rm -f "$tmp_css"
    echo "âœ… All Markdown files converted."
}


# merge all pdf files in current folder
alias mergepdfs='pdftk $(printf "%s\n" *.pdf | sort -V) cat output merged_output.pdf'

#=======================================================================
#  PACKAGE MANAGEMENT & SYSTEM UPDATES
#=======================================================================
# Aliases for installing, removing, and updating system packages.
alias install='sudo apt install -y'
alias remove='sudo apt purge -y'
alias installed=manually_installed
function manually_installed(){
	comm -23 <(apt-mark showmanual | sort -u) <(gzip -dc /var/log/installer/initial-status.gz | sed -n 's/^Package: //p' | sort -u)
}

alias update=updateall
function updateall(){
	sudo apt upgrade;
	sudo apt-get upgrade;
	sudo apt update;
	sudo apt-get update;
    updateChrome;
    sudo snap refresh;
	sudo apt-get clean;
	sudo apt clean;
	sudo apt autoremove;
	sudo apt-get autoremove;
	sudo apt-get autoclean;
	sudo apt autoclean;
}

function clean(){
	sudo apt-get clean;
	sudo apt clean;
	sudo apt autoremove;
	sudo apt-get autoremove;
	sudo apt-get autoclean;
	sudo apt autoclean;
}

updateChrome(){
   cd $HOME
   wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
   sudo dpkg -i google-chrome-stable_current_amd64.deb
   rm google-chrome-stable_current_amd64.deb
}


#=======================================================================
#  GIT & GITHUB WORKFLOW
#=======================================================================
# A comprehensive set of aliases and functions to streamline Git and GitHub usage.
alias lifeike='cd /home/feeco/Documents/feeco && gb && gs && yazi'
alias gb='git branch -a'
alias gitlastcommit='git diff --name-only HEAD^ | fzf --ansi \
  --preview "git diff --color=always HEAD^ -- {}" \
  --preview-window "right:70%" \
  --bind "tab:down,shift-tab:up,ctrl-k:preview-up,ctrl-j:preview-down"'
alias gitcommitscount='git shortlog -sn --all'
alias gitlistconflicts='git diff --check'
alias gittodolist='gh issue list'
alias gittodo='gh issue create'
alias gt='echo "local tags: " && git tag -n && echo "" && echo "" && echo "remote tags: " && git ls-remote --tags'
alias gnewtag='git tag -a'
alias gitconflict='git diff --name-only --diff-filter=U'
alias gl='git log -20 --graph --abbrev-commit --decorate=no --date=format:"%m-%d %H:%M" --format=format:"%C(03)%>|(15)%h%C(reset)  %an%C(reset) %C(04)%ad%C(reset)  %s%C(reset)  %C(bold 1)%d%C(reset) %C(reset)" --all'
alias gitbigfile='git rev-list --all | xargs -rL1 git ls-tree -r --long | sort -uk3 | sort -rnk4 | head -10'
alias gr='git reset --hard && git clean -fd'
alias gp='pushall'

gs() {
  local CYAN='\033[1;36m'
  local GREEN='\033[1;32m'
  local RED='\033[1;31m'
  local YELLOW='\033[1;33m'
  local MAGENTA='\033[1;35m'
  local BLUE='\033[1;34m'
  local DIM='\033[2m'
  local NC='\033[0m'

  local branch=$(git branch --show-current 2>/dev/null)
  local repo=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
  local ahead_behind=$(git rev-list --left-right --count HEAD...@{upstream} 2>/dev/null)
  local ahead=$(echo "$ahead_behind" | cut -f1)
  local behind=$(echo "$ahead_behind" | cut -f2)

  echo -e "\n${DIM}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${DIM}â•‘${NC}  ${MAGENTA}${repo}${NC} ${DIM}â”‚${NC} ${CYAN}${branch}${NC} ${ahead:+${GREEN}â†‘$ahead${NC}} ${behind:+${RED}â†“$behind${NC}}"
  echo -e "${DIM}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"

  local has_changes=false
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    has_changes=true
    local status="${line:0:2}"
    local file="${line:3}"
    case "$status" in
      "M ") echo -e "${DIM}â•‘${NC}  ${GREEN}  staged${NC}     $file" ;;
      " M") echo -e "${DIM}â•‘${NC}  ${CYAN}  modified${NC}  $file" ;;
      "MM") echo -e "${DIM}â•‘${NC}  ${YELLOW}  partial${NC}   $file" ;;
      "A ") echo -e "${DIM}â•‘${NC}  ${GREEN}  added${NC}     $file" ;;
      "AM") echo -e "${DIM}â•‘${NC}  ${YELLOW}  added+mod${NC} $file" ;;
      " D") echo -e "${DIM}â•‘${NC}  ${RED}  deleted${NC}   $file" ;;
      "D ") echo -e "${DIM}â•‘${NC}  ${RED}  staged-del${NC}$file" ;;
      "R ") echo -e "${DIM}â•‘${NC}  ${BLUE}  renamed${NC}   $file" ;;
      "??") echo -e "${DIM}â•‘${NC}  ${YELLOW}  untracked${NC} $file" ;;
      "UU") echo -e "${DIM}â•‘${NC}  ${RED}  conflict${NC}  $file" ;;
      *) echo -e "${DIM}â•‘${NC}  ${DIM}$status${NC}        $file" ;;
    esac
  done < <(git status --short 2>/dev/null)

  if [[ "$has_changes" == false ]]; then
    echo -e "${DIM}â•‘${NC}  ${GREEN}  clean${NC}     working tree is clean"
  fi

  echo -e "${DIM}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
}

declare -A GH_ALIAS_MAP=(
    [hankAndfeeco]=hankAndfeeco
    [lifeike]=lifeike
)

function pushall(){
    IFS= read -r -p "commit message: " commitMessage
    git add -A;
    git commit --allow-empty -am "$commitMessage";
    branch=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
    git push -u origin $branch
    clear
}

function gitdeploy(){
   git checkout main
   git merge staging
   git push origin main
   git checkout staging
}

alias githublogin='gh auth login'
alias githubbrowser='gh browse'
alias githubrepos='ghclone'
alias githuborganizationrepos='ghcloneorg'

ghcloneorg() {
    local org
    org=$(gh api user/orgs --jq '.[].login' 2>/dev/null | fzf --height=40% --reverse --prompt='Organization> ')
    [[ -z "$org" ]] && return
    local repo
    repo=$(
        gh repo list "$org" \
            --limit 100 \
            --json nameWithOwner,description \
            --jq '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
        fzf \
            --height=80% \
            --layout=reverse \
            --prompt="$org repo > " \
            --delimiter=$'\t' \
            --with-nth=1,2 \
            --bind='tab:down,shift-tab:up,ctrl-j:down,ctrl-k:up' \
            --preview 'echo {2}' \
            --preview-window=down:3:wrap |
        cut -f1
    )
    [[ -n "$repo" ]] && gh repo clone "$repo"
}

github() {
    local user
    user=$(gh auth status 2>&1 | grep -oP 'account \K\S+' | fzf --height=40% --reverse --prompt='GitHub User> ')
    if [[ -n "$user" ]]; then
        gh auth switch --user "$user"
        echo "=== $user ==="
        gh repo list "$user" --limit 100
        local orgs
        orgs=$(gh api user/orgs --jq '.[].login' 2>/dev/null)
        for org in $orgs; do
            echo ""
            echo "=== $org ==="
            gh repo list "$org" --limit 100
        done
    fi
}

ghclone() {
  local repo
  repo=$(
    gh repo list \
      --limit 100 \
      --json nameWithOwner,description \
      --jq '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf \
      --height=80% \
      --layout=reverse \
      --prompt="Clone repo > " \
      --delimiter=$'\t' \
      --with-nth=1,2 \
      --bind='tab:down,shift-tab:up,ctrl-j:down,ctrl-k:up' \
      --preview 'echo {2}' \
      --preview-window=down:3:wrap |
    cut -f1
  )
  [[ -n "$repo" ]] && gh repo clone "$repo"
}

gc() {
    local repo_dir
    repo_dir=$(basename "${1%/}" .git)
    gh repo clone "$1" || return
    cd "$repo_dir" || return
    for branch in $(git branch -r | grep -v '\->'); do
        git branch --track "${branch#origin/}" "$branch" 2>/dev/null
    done
    git fetch --all
    nvim .
}


#=======================================================================
#  TMUX - TERMINAL MULTIPLEXER
#=======================================================================
# Functions and aliases for managing Tmux sessions, windows, and layouts.
alias tnewsession=createNewSessionInsideTmuxSession
alias tkill=killTmuxSession 
alias layout=defaultLayout
alias project=projectLayout
alias tnewwindow='tmux new-window -n ' 
alias twindowname='tmux rename-window '
alias tsessionname='tmux rename-session '
alias lw='tmw'
alias w='tmw'

tmw() {
  local target
  target=$(tmux list-windows -a -F "#{session_name}:#{window_index} | #{session_name} > #{window_name} #{?window_active,(active),}" | \
    fzf-tmux -p 80% --reverse --header "Search Sessions & Windows" \
    --delimiter "|" --with-nth 2 | \
    cut -d " " -f 1)

  if [[ -n "$target" ]]; then
    tmux switch-client -t "${target%:}"
  fi
}

function createNewSessionInsideTmuxSession(){
    session_name=$1
    tmux has-session -t=$session_name 2> /dev/null
    if [[ $? -ne 0 ]]; then
      TMUX='' tmux new-session -d -s "$session_name"
    fi
    if [[ -z "$TMUX" ]]; then
      tmux attach -t "$session_name"
    else
      tmux switch-client -t "$session_name"
    fi
}

function killTmuxSession(){
  tls;
  IFS= read -r -p "input session name: " sessionName
  tmux switch-client -t main &&
  tmux kill-session -t "$sessionName" ;
}

function defaultLayout(){
  tmux selectp -t 0;
  tmux splitw -v -p 40;
  tmux splitw -h -p 50;
  tmux splitw -v -p 50;
  tmux selectp -t 1;
  tmux splitw -v -p 50;
  tmux send-keys -t1 music Enter ;
  tmux send-keys -t1 yazi Enter ;
  tmux send-keys -t4 "cd ~/Downloads" Enter ;
  tmux selectp -t 0;
}

function projectLayout(){
  tmux selectp -t 0;
  tmux splitw -h -p 50;
  tmux selectp -t 1;
  tmux splitw -v -p 50;
  tmux selectp -t 0;
  tmux send-keys -t0 claude --chrome Enter;
}


#=======================================================================
#  DEVELOPMENT
#=======================================================================
# Aliases and functions for development-related tasks (Node.js, Prisma, etc.).
alias npminstalled='npm list --global --depth=0'
function updatePrismaSchema(){
 npx prisma db pull
 npx prisma generate
}


#=======================================================================
#  MEDIA & YOUTUBE
#=======================================================================
# Aliases for downloading media and playing audio.
alias youtubesubtitle='youtube-dl --sub-lang en --convert-subs srt --write-sub'
alias mp3='mpv --no-video '
alias youtubedownloadmp3='youtube -xiwc --audio-format mp3 '
alias youtube='yt-dlp -o "%(title)s.%(ext)s"'
alias youtubechannelrelease='yt-dlp -x --audio-format mp3 -o "%(uploader)s/[%(upload_date>%Y)s] %(album,playlist_title)s/%(track_number,playlist_index)02d - %(title)s.%(ext)s" --add-metadata --embed-thumbnail --yes-playlist '
alias youtubeplayliststartfrom='_ytplv() { yt-dlp -o "%(uploader)s/[%(upload_date>%Y)s] %(playlist_title)s/%(playlist_index)02d - %(title)s.%(ext)s" --add-metadata --embed-thumbnail --write-info-json --yes-playlist --playlist-start "$1" "$2"; }; _ytplv'


#=======================================================================
#  DOTFILES MANAGEMENT
#=======================================================================
# Aliases for managing dotfiles and reloading shell configuration.
load() {
  source ~/.bashrc
  source ~/.profile
  [ -n "$TMUX" ] && tmux source-file ~/.tmux.conf
  echo "dotfiles reloaded..."
  echo "to reload awesomeWM, use following command"
  echo "super+ctrl+r"
}

alias updatedotfiles='chezmoi re-add'
alias syncdotfiles='cd ~/Desktop && chezmoi update'
alias cddotfiles='chezmoi cd && echo "current path" && pwd'
alias adddotfiles='chezmoi add'
alias removedotfiles='chezmoi destroy'
alias cs='chezmoi status'


#=======================================================================
#  DISK & OS UTILITIES
#=======================================================================
# Functions for disk reporting and creating bootable USB drives.
diskreport() {
  RED="\e[31m"
  GREEN="\e[32m"
  CYAN="\e[36m"
  YELLOW="\e[33m"
  BOLD="\e[1m"
  RESET="\e[0m"

  echo -e "${BOLD}${CYAN}=== ğŸ” Disk and OS Information Report ===${RESET}\n"
  echo -e "${YELLOW}ğŸ‘‰ Physical Disks and Partitions:${RESET}"
  lsblk -o NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT,TYPE | grep -E "disk|part" | grep -v "loop"
  echo
  echo -e "${YELLOW}ğŸ‘‰ Detailed Partition Layout (fdisk):${RESET}"
  sudo fdisk -l | grep -E "Disk /dev/(sd|nvme)"
  echo
  echo -e "${YELLOW}ğŸ‘‰ Currently Mounted Filesystems:${RESET}"
  mount | grep '^/dev/' | grep -v "loop"
  echo
  echo -e "${YELLOW}ğŸ‘‰ UEFI Boot Entries (Bootloaders in firmware):${RESET}"
  sudo efibootmgr -v
  echo
  echo -e "${YELLOW}ğŸ‘‰ Current Linux Distribution:${RESET}"
  grep -E 'PRETTY_NAME|VERSION=' /etc/os-release
  echo
  echo -e "${YELLOW}ğŸ‘‰ Kernel and System Architecture:${RESET}"
  uname -a
  echo
  echo -e "${YELLOW}ğŸ‘‰ Checking for Windows Partitions (NTFS):${RESET}"
  lsblk -o NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT,TYPE | grep ntfs || echo -e "${RED}No Windows partitions found.${RESET}"
  echo
  echo -e "${GREEN}${BOLD}=== âœ… Report Complete ===${RESET}"
}

burnWindowUSB(){
  echo '1. run "diskrepot" command and find the mounted usb device, usually /dev/sda or /dev/sdb'
  echo "2. install woeusb"
  echo '3. sudo woeusb --target-filesystem NTFS --device "path/to/windows.iso" "/dev/sdX"'
  echo "4. takes about 1-2 hours to burn to usb"
}

burnLinuxUSB(){
  echo '1. run "diskrepot" command and find the mounted usb device, usually /dev/sda or /dev/sdb'
  echo '2. sudo dd if=linux.iso of=/dev/sdb bs=4M status=progress oflag=sync'
  echo "3. takes about 1-2 hours to burn to usb"
}


#=======================================================================
#  YAZI FILE MANAGER
#=======================================================================
source ~/.config/yazi/yazi.sh

