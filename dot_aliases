#################################################################################################################################################
#################################################################################################################################################
#####################################
#####################################          Bash Aliases.   Feike Li     2020.5.2 ver
#####################################          write some documentation formatting here:
#####################################
#####################################	         1.temp aliases
#####################################          2.system aliases
#####################################	         3.applications
#####################################
#####################################
#################################################################################################################################################
#################################################################################################################################################

#----------------------
# temp alias
#----------------------
alias co='copilot '          
alias p='pwd '          
alias t3='npm create t3-app@latest'          
alias dockerBuild='docker build . '          
alias connectToAwsFargateDocker='copilot svc exec --app dmrv --env staging --name service-dmrv'

#---------------------
# system aliases
#---------------------
alias f='tmux a' 
alias c='clear'
alias h='cd $HOME && clear'
alias q='exit'
alias k='sudo killall '
alias w='curl wttr.in/calgary?1'
alias n='sudo n'
alias e='gedit '
alias password='nvim ~/Documents/feeco/1.lifeike/password.txt'
alias pi='pip3 install '
alias p3='python3 '
alias d='cd /home/feeco/Downloads && ranger'
alias document='cd /home/feeco/Documents && ranger'
alias desktop='cd /home/feeco/Desktop && ranger'
alias music='cd /home/feeco/Music && ranger'
alias video='cd /home/feeco/Videos && ranger'
alias picture='cd /home/feeco/Pictures && ranger'
alias install='sudo apt install -y'
alias remove='sudo apt purge -y'
alias tree='tree -a'
alias screenoff='gsettings set org.gnome.desktop.session idle-delay'
alias process='ps -ef | grep'
alias biggestFile='find . -type f -exec du -h {} + | sort -hr | head -20'
alias ds='ncdu ~'
alias s='cdf'
alias clear='clear && tmux clear-history'
alias m='helpfzf'


# port in used.
alias portinused='lsof -i -P -n'
alias data='vnstat'
ip(){
  echo "==========="
  echo "signal strength"
  echo "-67 dBm	Reliable signal strength."
  echo "-70 dBm	Not a strong signal."
  echo "-80 dBm	Unreliable signal strength, will not suffice for most services."
  echo "-90 dBm	The chances of even connecting are very low at this level."  

  iwconfig
  echo "==========="
  echo "signal information"

  ifconfig
}

#mark current directory as mm
mark(){
    dir=$PWD
    #sed -i  "5s|.*|\"$dir\"|g" ~/Desktop/a.txt 
    sed -i  "18s|.*|alias mm=\"cd $dir \&\& ranger \"|g" ~/.aliases 
    load_resource_rcfiles
}


#-------------------------------
# unzip unrar
#-------------------------------
alias unrarall='for file in *.rar; do unrar e -p "$file"; done'
alias unzipgarbled='unzip -O cp936 '  #unzip and solve garbled issue


look() {
    if [ $# -eq 0 ]; then
        echo "Please provide a domain name."
        return 1
    fi
    
    local domain="$1"
    
    # whois "$domain" | less
    whois "$domain" | \
    awk '/Creation Date/ {print "\033[31m" $0 "\033[0m"} {print}' | \
    less -R
}



#-------------------------------
# wechat å¾®ä¿¡
#-------------------------------
## è¿è¡Œå¾®ä¿¡
alias wechat-start='singularity exec -B /run /opt/wechat.sif /opt/apps/com.qq.weixin.deepin/files/run.sh'
# å”¤å‡ºå·²è¿è¡Œçš„WeChatçª—å£
alias wechat='singularity exec /opt/wechat.sif /opt/deepinwine/tools/sendkeys.sh w wechat 4'
# å¾®ä¿¡æˆªå›¾
alias wechat-screenshot='singularity exec /opt/wechat.sif /opt/deepinwine/tools/sendkeys.sh a wechat 3'
# é€€å‡ºå¾®ä¿¡
alias wechat-quit="singularity exec /opt/wechat.sif /opt/deepinwine/tools/kill.sh wechat"
          
          
#-------------------------------
# brightness
#-------------------------------
#get monitors you're using:     xrandr | grep " connected" | cut -f1 -d " "
#change the brightness level:   xrandr --output eDP-1 --brightness 0.2
alias 1="echo 1 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null   && xrandr --output eDP-1 --brightness 1   "
alias 2="echo 100 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null && xrandr --output eDP-1 --brightness 1   "
alias 3="echo 200 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null && xrandr --output eDP-1 --brightness 1   "
alias 4="echo 300 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null && xrandr --output eDP-1 --brightness 1   "
alias 5="echo 400 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null && xrandr --output eDP-1 --brightness 1   "
alias 6="echo 500 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null && xrandr --output eDP-1 --brightness 1   "
alias 7="echo 600 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null && xrandr --output eDP-1 --brightness 1   "
alias 8="echo 700 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null && xrandr --output eDP-1 --brightness 1   "
alias 9="echo 800 | sudo tee /sys/class/backlight/intel_backlight/brightness > /dev/null  && xrandr --output eDP-1 --brightness 1.2  "


#-------------------------------
# sound volume
#-------------------------------
alias 11='amixer sset "Master" 10%'
alias 22='amixer sset "Master" 20%'
alias 33='amixer sset "Master" 30%'
alias 44='amixer sset "Master" 40%'
alias 55='amixer sset "Master" 50%'
alias 66='amixer sset "Master" 60%'
alias 77='amixer sset "Master" 70%'
alias 88='amixer sset "Master" 80%'
alias 99='amixer sset "Master" 90%'
alias 00='amixer sset "Master" 100%'
alias soundRestart='pulseaudio -k && sudo alsa force-reload'

#-------------------------------
# fzf
#-------------------------------
alias pdf='cd $HOME && zathura --mode fullscreen "$(fzf)" '

# Optimized Interactive CLI Help with fzf
# Vim-Style Interactive CLI Help with fzf (Telescope-like experience)
helpfzf() {
    local cmd="$1"
    shift
    local extra_args="$*"
    
    if ! command -v "$cmd" &> /dev/null; then
        echo "âŒ Command not found: $cmd"
        return 1
    fi
    
    if ! command -v fzf &> /dev/null; then
        echo "âŒ fzf not found. Install with: brew install fzf"
        return 1
    fi
    
    echo "ğŸ” Loading help for: $cmd"
    
    # Get the best available help (avoid duplicates)
    local help_content=""
    local help_source=""
    
    # Try different help methods in order of preference
    local methods=("help" "--help" "-h")
    for method in "${methods[@]}"; do
        local temp_help
        temp_help=$("$cmd" "$method" 2>&1 || true)
        
        # Check if we got useful help (not error messages)
        if [[ -n "$temp_help" ]] && 
           [[ ! "$temp_help" =~ "unknown option" ]] && 
           [[ ! "$temp_help" =~ "invalid option" ]] && 
           [[ ! "$temp_help" =~ "unrecognized option" ]] &&
           [[ ${#temp_help} -gt 50 ]]; then
            help_content="$temp_help"
            help_source="$cmd $method"
            break
        fi
    done
    
    # Fall back to man page if no help found
    if [[ -z "$help_content" ]]; then
        if man "$cmd" >/dev/null 2>&1; then
            help_content=$(man "$cmd" 2>/dev/null)
            help_source="man $cmd"
        else
            # Try running with no args as last resort
            help_content=$("$cmd" 2>&1 || true)
            help_source="$cmd (no args)"
        fi
    fi
    
    if [[ -z "$help_content" ]]; then
        echo "âŒ No help available for $cmd"
        return 1
    fi
    
    # Parse help content to extract actionable items
    local temp_file=$(mktemp)
    
    {
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“š Help Source: $help_source"
        echo "ğŸ¯ Command: $cmd"
        [[ -n "$extra_args" ]] && echo "ğŸ“ Extra Args: $extra_args"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        
        # Extract and categorize content
        echo "ğŸš€ QUICK ACTIONS:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        # Extract subcommands (common patterns)
        local subcommands
        subcommands=$(echo "$help_content" | \
            grep -E "^[[:space:]]*[a-z][a-z0-9_-]{2,}[[:space:]]" | \
            grep -v "^[[:space:]]*-" | \
            awk '{print $1}' | \
            sort -u | \
            head -15)
        
        if [[ -n "$subcommands" ]]; then
            echo "$subcommands" | while IFS= read -r subcmd; do
                local desc
                desc=$(echo "$help_content" | grep -E "^[[:space:]]*$subcmd[[:space:]]" | head -1 | sed "s/^[[:space:]]*$subcmd[[:space:]]*//" | cut -c1-70)
                printf "â–¶ï¸  RUN: %-15s â”‚ %s\n" "$subcmd" "$desc"
            done
            echo ""
        fi
        
        # Extract common options
        echo "âš™ï¸  COMMON OPTIONS:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "$help_content" | \
            grep -E "^[[:space:]]*(-[a-zA-Z]|--[a-zA-Z])" | \
            head -12 | \
            while IFS= read -r line; do
                local option=$(echo "$line" | awk '{print $1}')
                local desc=$(echo "$line" | sed 's/^[[:space:]]*[^[:space:]]*[[:space:]]*//' | cut -c1-65)
                printf "ğŸ”§ USE: %-20s â”‚ %s\n" "$option" "$desc"
            done
        echo ""
        
        # Show usage patterns
        echo "ğŸ“– USAGE PATTERNS:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "$help_content" | \
            grep -i -E "(usage|synopsis):" -A 3 | \
            grep -v "^--$" | \
            sed 's/^[[:space:]]*/ğŸ“‹ /'
        echo ""
        
        echo "ğŸ“„ FULL HELP CONTENT:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "$help_content"
        
    } > "$temp_file"
    
    # Vim-style fzf with Telescope-like bindings (maximum compatibility)
    local selection
    selection=$(cat "$temp_file" | \
        fzf --ansi \
            --height=90% \
            --layout=reverse \
            --border \
            --prompt="ğŸ” $cmd â¯ " \
            --header="j/k: navigate â”‚ i: search â”‚ Enter: select â”‚ Tab: preview â”‚ Esc: exit" \
            --preview-window="right:50%" \
            --preview="echo 'Selected: {}' | fold -w 45" \
            --bind="j:down" \
            --bind="k:up" \
            --bind="ctrl-d:half-page-down" \
            --bind="ctrl-u:half-page-up" \
            --bind="tab:toggle-preview" \
            --bind="ctrl-y:execute-silent(echo {} | pbcopy)" \
            --bind="esc:abort" \
            --bind="enter:accept" \
    )
    
    # Clean up temp file
    rm -f "$temp_file"
    
    # Process the selection
    if [[ -n "$selection" ]]; then
        # Check if it's a runnable action
        if [[ "$selection" =~ ^â–¶ï¸[[:space:]]*RUN:[[:space:]]*([^[:space:]â”‚]+) ]]; then
            local subcmd="${BASH_REMATCH[1]}"
            local full_command="$cmd $subcmd $extra_args"
            
            echo ""
            echo "ğŸš€ Detected subcommand: $subcmd"
            
            # Vim-style argument input with completion
            echo "ğŸ’¬ Additional arguments for '$cmd $subcmd':"
            echo "   Press Tab for suggestions, Ctrl+C to cancel"
            echo -n "â¯ "
            read -e -r additional_args  # -e enables readline editing
            
            [[ -n "$additional_args" ]] && full_command="$cmd $subcmd $additional_args $extra_args"
            
            echo ""
            echo "ğŸ”¥ Running: $full_command"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            
            # Safety check for destructive commands
            case "$cmd $subcmd" in
                *"rm "*|*"delete "*|*"destroy "*|*"drop "*|*"remove "*)
                    echo "âš ï¸  This command might be destructive!"
                    echo -n "Are you sure? [y/N]: "
                    read -r confirm
                    [[ "$confirm" != "y" && "$confirm" != "Y" ]] && return 0
                    ;;
            esac
            
            eval "$full_command"
            
        elif [[ "$selection" =~ ^ğŸ”§[[:space:]]*USE:[[:space:]]*([^[:space:]â”‚]+) ]]; then
            local option="${BASH_REMATCH[1]}"
            local full_command="$cmd $option $extra_args"
            
            echo ""
            echo "ğŸ”§ Selected option: $option"
            echo -n "â¯ Additional arguments: "
            read -e -r additional_args
            
            [[ -n "$additional_args" ]] && full_command="$cmd $option $additional_args $extra_args"
            
            echo ""
            echo "ğŸ”¥ Running: $full_command"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            eval "$full_command"
            
        else
            # Just show what was selected (for learning)
            echo ""
            echo "ğŸ“‹ Selected:"
            echo "$selection"
            echo ""
            echo "ğŸ’¡ This was informational. To run a command, select lines starting with â–¶ï¸  or ğŸ”§"
        fi
    fi
}


#find file and navigate to the directory
ff(){

    cd $HOME
    file=$(fzf -q "$1")
    dir=$(dirname "$file")
    ranger "$dir"
}

#-------------------------------
# chrome
#-------------------------------
updateChrome(){
   cd $HOME
   wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
   sudo dpkg -i google-chrome-stable_current_amd64.deb
   rm google-chrome-stable_current_amd64.deb
}

function alternative(){
	google-chrome https://alternativeto.net/software/$1/?platform=linux&sort=likes
}
#-------------------------------
# file formatting
#-------------------------------
# covert all pdf to text file in the current folder/directory
alias convertallpdf='ls *.pdf | xargs -n1 pdftotext'
# covert all pdf to png file in the current folder/directory
alias convertallpdftopng=allpdftopng
function allpdftopng(){

	for file in *.pdf;
		do pdftoppm "$file" "$file";
	done
}
# convert ppt to pdf
alias convertpptxtopdf='libreoffice --headless --invisible --convert-to pdf *.pptx'
# convert doc/docx to text
alias convertdocxtotxt='libreoffice --headless --convert-to txt'
# convert images to pdf
alias convertjpgtopdf='convert *.jpg output.pdf'


#---------------------
# applications
#---------------------
#nodejs npm
alias ni='npm install && npm run start'
alias nb='npm run build '

#list all app installed manually
alias installed=manually_installed
function manually_installed(){
	comm -23 <(apt-mark showmanual | sort -u) <(gzip -dc /var/log/installer/initial-status.gz | sed -n 's/^Package: //p' | sort -u)
}

#update and upgrade packages
alias update=updateall
function updateall(){
	sudo apt upgrade;
	sudo apt-get upgrade;
	sudo apt update;
	sudo apt-get update;
  updateChrome;
  sudo snap refresh;
  python3 -m pip install -U yt-dlp;
	sudo apt-get clean;
	sudo apt clean;
	sudo apt autoremove;
	sudo apt-get autoremove;
	sudo apt-get autoclean;
	sudo apt autoclean;
}

function clean(){
	sudo apt-get clean;
	sudo apt clean;
	sudo apt autoremove;
	sudo apt-get autoremove;
	sudo apt-get autoclean;
	sudo apt autoclean;
}


# apps
alias v='nvim'
alias r='ranger'

##########################
#  youtube-dl
##########################

#alias youtubedownloadmp3='youtube-dl -xiwc --audio-format mp3 '
#alias youtube='youtube-dl -o "%(title)s.%(ext)s"'
alias youtubesubtitle='youtube-dl --sub-lang en --convert-subs srt --write-sub'

##########################
#  mpv
###########################
alias mp3='mpv --no-video '

##########################
#  yt-dlp
###########################
alias youtubedownloadmp3='youtube -xiwc --audio-format mp3 '
alias youtube='yt-dlp -o "%(title)s.%(ext)s"'

# load all source files
alias load='source ~/.bashrc && source ~/.profile && tmux source-file ~/.tmux.conf'

#########################
#   tmux
#########################
# open tmux fullscreen with sessions attached
alias tnew=createNewSessionInsideTmuxSession

function createNewSessionInsideTmuxSession(){
session_name=$1
# 1. First you check if a tmux session exists with a given name.
tmux has-session -t=$session_name 2> /dev/null
# 2. Create the session if it doesn't exists.
if [[ $? -ne 0 ]]; then
  TMUX='' tmux new-session -d -s "$session_name"
fi
# 3. Attach if outside of tmux, switch if you're in tmux.
if [[ -z "$TMUX" ]]; then
  tmux attach -t "$session_name"
else
  tmux switch-client -t "$session_name"
fi
}


alias tkill=killTmuxSession 
function killTmuxSession(){
  tls;
  IFS= read -r -p "input session name: " sessionName
  tmux switch-client -t main && #switch to main session before target session killed
  tmux kill-session -t "$sessionName" ;
}

#main session layout
alias layout=defaultLayout
function defaultLayout(){
  tmux selectp -t 0;
  tmux splitw -v -p 40;  #split vertically
  tmux splitw -h -p 50;
  tmux splitw -v -p 50;
  tmux selectp -t 1;     #select pane number 1
  tmux splitw -v -p 50;
  tmux send-keys -t2 music Enter ;
  tmux send-keys -t2 ranger Enter ;
  tmux send-keys -t4 "cd ~/Downloads" Enter ;
  tmux selectp -t 0;
}

#project session layout
alias project=projectLayout
function projectLayout(){
  tmux selectp -t 0;
  tmux splitw -v -p 60;  #split vertically
  tmux splitw -h -p 50;
  tmux selectp -t 0;
}

#create new window
alias tnewwindow='tmux new-window -n ' 
#rename the current window
alias twindowname='tmux rename-window '
#list all session and windows
alias l='tmux choose-window '

#----------------------------
# application github
#----------------------------
alias lifeike='cd /home/feeco/Documents/feeco && gb && gs && ranger'
alias gb='git branch --sort=committerdate | column'
alias gitlastcommit='git diff HEAD^ '
alias gitcommitscount='git shortlog -sn --all'
alias gitlistconflicts='git diff --check'
alias gittodolist='gh issue list'
alias gittodo='gh issue create'

# git status
gs() {
  echo "== Current Branch : $(git branch --show-current)=========================="
  while IFS= read -r line; do
    status="${line:0:2}"
    file="${line:3}"
    case "$status" in
      " M") echo -e "\033[36m$line\033[0m" ;;  # Cyan for Modified
      "A ") echo -e "\033[32m$line\033[0m" ;;  # Green for Added
      " D") echo -e "\033[34m$line\033[0m" ;;  # Red for Deleted
      "??") echo -e "\033[33m$line\033[0m" ;;  # Yellow for Untracked
      *) echo "$line" ;;
    esac
  done < <(git status --short)
  echo "== Current Directory : $(basename "$PWD")====================================="
}

#git tags
alias gt='echo "local tags: " && git tag -n && echo "" && echo "" && echo "remote tags: " && git ls-remote --tags'
alias gnewtag='git tag -a' #append the tag name after

#list all conflict files
alias gitconflict='git diff --name-only --diff-filter=U'
#alias gl='git log -20 --abbrev-commit --pretty=oneline --graph'
alias gl='git log -20 --graph --abbrev-commit --decorate=no --date=format:"%m-%d %H:%M" --format=format:"%C(03)%>|(15)%h%C(reset)  %an%C(reset) %C(04)%ad%C(reset)  %s%C(reset)  %C(bold 1)%d%C(reset) %C(reset)" --all'
alias gitbigfile='git rev-list --all | xargs -rL1 git ls-tree -r --long | sort -uk3 | sort -rnk4 | head -10'
# git discard all local changes and remove all untracked files(new files)
alias gr='git reset --hard && git clean -fd'

# open a git project then open source code in vscode then run this project
alias open=git-open-project
function git-open-project(){
    git-clone-all-branches $1 && code -r . && npm install &&  npm run start
}

# clone a git repo with all remote branches
alias gc=git-clone-all-branches
function git-clone-all-branches(){
    #go to source code folder
    git clone $1
    basename=$(basename $1)
    filename=${basename%.*}
    cd $filename

    #clone all remote branches from remote
for branch in `git branch -a | grep remotes | grep -v HEAD | grep -v master`; do
        #rename remote branches to local branch( remotes/origin/hello --> hello )
        git branch --track ${branch##remotes/origin/} $branch
            done
        }


# gcot - git checkout branch/tag
ggb() {
  local tags branches target
  tags=$(
    git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}') || return
  branches=$(
    git branch --all | grep -v HEAD             |
    sed "s/.* //"    | sed "s#remotes/[^/]*/##" |
    sort -u          | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}') || return
  target=$(
    (echo "$tags"; echo "$branches") |
    fzf-tmux -- --no-hscroll --ansi +m -d "\t" -n 2) || return
  git checkout $(echo "$target" | awk '{print $2}')
}

alias gp='pushall'
function pushall(){
    #read -p 'commit message: ' commitMessage
    IFS= read -r -p "commit message: " commitMessage
    git add -A;
    git commit --allow-empty -am "$commitMessage";
    branch=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
    git push -u origin $branch
    clear
}

# git deploy 
function gitdeploy(){
   git checkout main
   git merge staging
   git push origin main
   git checkout staging
}

#-----------------
# npm + mongodb
#-----------------
alias npminstalled='npm list --global --depth=0'
alias mongo='mongosh "mongodb+srv://cluster0.de2gw.mongodb.net/myFirstDatabase" --username feeco --password Test@1234'


#-----------------
# ffmpeg
#-----------------
# merge video with subtitles
alias combinevideosubtitle=combine_video_and_subtitles
function combine_video_and_subtitles(){

    ffmpeg -i $1 -i $2 -c:s mov_text -c:v copy -c:a copy output.mp4

}

# split video into 10 mins clip
# ffmpeg -i fff.avi -acodec copy -f segment -segment_time 10 -vcodec copy -reset_timestamps 1 -map 0 fff%d.avi
alias splitvideo='split_big_video_into_clips_of_10mins'
function split_big_video_into_clips_of_10mins(){
	local input=$1;
	ffmpeg -i $1 -acodec copy -f segment -segment_time 600 -vcodec copy -reset_timestamps 1 -map 0 $1%d.avi
}

#-----------------
# fuzzy finder
#-----------------
# cdf - cd into the directory of the selected file
cdf() {
   cd ~
   local file
   local dir
   file=$(fzf +m -q "$1") && dir=$(dirname "$file") 
   cd "$dir"
   pwd
}

alias vf='cd $HOME && vim $(fzf)'

#-----------------
# chezmoi
#-----------------
alias update-dotfiles='chezmoi re-add'
alias sync-dotfiles='chezmoi update'
alias cd-dotfiles='cd ~/.local/share/chezmoi && ranger'
alias add-dotfiles='chezmoi add'
alias cs='chezmoi status'

##########################
#  node prisma
###########################
function updatePrismaSchema(){
 npx prisma db pull
 npx prisma generate
}


#------------------------------------
# postgresql database running locally
#------------------------------------
# PostgreSQL Alias Cheatsheet (MongoDB-like Syntax)
# Database & Connection
alias showdbs='psql -c "\l"'                    #	\l	List all databases
alias usedb='psql -d '                          #	\c  dbname	Switch database
alias currentdb='psql -c "\conninfo"'	          # \conninfo	Show current DB connection
# Tables & Schemas
alias showtables='psql -c "\dt"'	              # \dt	List tables in current DB
alias showalltables='psql -c "\dt *.*"'	        # \dt *.*	List all tables (including system schemas)
alias desc='psql -c "\d+"'	                    # \d+ table	Describe a table (structure, indexes, etc.)
# User & Roles
alias showusers='psql -c "\du"'	                # \du	List all users/roles
alias showgrants='psql -c "\dp"'                #	\dp	Show table permissions
# Query & Admin Shortcuts
alias query='psql -c'	                          # SELECT ...	Run a quick SQL query
alias explain='psql -c "EXPLAIN ANALYZE"'	      # EXPLAIN ANALYZE ...	Analyze query performance
alias killconn='psql -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE ..."'	   # pg_terminate_backend()	Kill a stuck connection
# Export & Import
alias exportdb='pg_dump -U user -d dbname -f output.sql'	# pg_dump	Export DB to SQL file
alias importdb='psql -U user -d dbname -f input.sql'	# psql -f	Import SQL file into DB


