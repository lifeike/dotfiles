#################################################################################################################################################
#################################################################################################################################################
#####################################
#####################################          Bash Aliases.   Feike Li     2020.5.2 ver
#####################################          write some documentation formatting here:
#####################################
#####################################	         1.temp aliases
#####################################          2.system aliases
#####################################	         3.applications
#####################################
#####################################
#################################################################################################################################################
#################################################################################################################################################

#----------------------
# temp alias
#----------------------
alias t3='npm create t3-app@latest'          

#---------------------
# system aliases
#---------------------
alias v='nvim'
alias r='ranger'
alias f='tmux a' 
alias c='clear'
alias h='cd $HOME && clear'
alias q='exit'
alias n='sudo n'
alias password='nvim ~/Documents/feeco/1.lifeike/password.txt'
alias pi='pip3 install '
alias p3='python3 '
alias d='cd /home/feeco/Downloads && ranger'
alias repos='cd /home/feeco/Documents && ranger'
alias desktop='cd /home/feeco/Desktop && ranger'
alias music='cd /home/feeco/Music && ranger'
alias video='cd /home/feeco/Videos && ranger'
alias picture='cd /home/feeco/Pictures && ranger'
alias install='sudo apt install -y'
alias remove='sudo apt purge -y'
alias tree='tree -a'
alias process='ps -ef | grep'
alias biggestFile='find . -type f -exec du -h {} + | sort -hr | head -20'
alias ds='ncdu ~'
alias s='cdf'
alias clear='clear && tmux clear-history'
alias m='helpfzf'
alias cd-ssh='cd ~/.ssh && ranger'
alias p='pwd '          
alias top='btop'
alias t='btop'
alias config='cd ~/.config && ranger'
alias vali='nvim ~/.aliases'
alias ls='ls -lAhvFis --color=always --group-directories-first --time-style="+%Y-%m-%d %H:%M"'
alias o='nvim ~/Desktop/text.txt'
alias e='neomutt'

# wifi connection
alias wifilist='nmcli device wifi list'
connect_wifi() {
    # Prompt for SSID
    read -r -p "Enter SSID: " ssid
    
    # Prompt for password silently (-s flag hides input)
    read -r -s -p "Enter Password: " password
    echo # Move to a new line after silent input
    
    # Connect using nmcli
    # Use quotes around variables to handle SSIDs/passwords with spaces or special characters
    sudo nmcli device wifi connect "$ssid" password "$password"
}

# Beautiful netstat formatter with search and filter
port() {
    local search_term="${1:-}"
    
    # Color codes
    local GREEN='\033[0;32m'
    local BLUE='\033[0;34m'
    local YELLOW='\033[1;33m'
    local CYAN='\033[1;36m'
    local NC='\033[0m'
    
    echo -e "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo -e "â•‘                        NETWORK PORTS & CONNECTIONS                         â•‘"
    echo -e "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
    
    printf "%-10s %-25s %-10s %-15s %-12s %s\n" "PROTO" "LOCAL ADDRESS" "PORT" "STATE" "PID" "PROGRAM"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    sudo netstat -tulpn 2>/dev/null | grep -v "^Active\|^Proto" | while read -r line; do
        [ -z "$line" ] && continue
        
        proto=$(echo "$line" | awk '{print $1}')
        local_addr=$(echo "$line" | awk '{print $4}')
        
        # For UDP, there's no state column
        if [[ $proto == udp* ]]; then
            state="-"
            pid_program=$(echo "$line" | awk '{print $6}')
        else
            state=$(echo "$line" | awk '{print $6}')
            pid_program=$(echo "$line" | awk '{print $7}')
        fi
        
        if [[ $local_addr == *":"* ]]; then
            ip=$(echo "$local_addr" | rev | cut -d: -f2- | rev)
            port=$(echo "$local_addr" | rev | cut -d: -f1 | rev)
        else
            ip="N/A"
            port="N/A"
        fi
        
        if [[ $pid_program == *"/"* ]]; then
            pid=$(echo "$pid_program" | cut -d/ -f1)
            program=$(echo "$pid_program" | cut -d/ -f2-)
        elif [[ $pid_program == "-" ]]; then
            pid="-"
            program="-"
        else
            pid="${pid_program:-N/A}"
            program="N/A"
        fi
        
        [ -n "$search_term" ] && ! echo "$line $program $port" | grep -qi "$search_term" && continue
        
        # Apply colors to protocol
        case $proto in
            tcp*) proto_colored="${GREEN}${proto}${NC}" ;;
            udp*) proto_colored="${BLUE}${proto}${NC}" ;;
            *) proto_colored="$proto" ;;
        esac
        
        # Apply colors to state
        case $state in
            LISTEN) state_colored="${YELLOW}${state}${NC}" ;;
            ESTABLISHED) state_colored="${GREEN}${state}${NC}" ;;
            *) state_colored="$state" ;;
        esac
        
        # Apply color to port
        port_colored="${CYAN}${port}${NC}"
        
        # Print with proper alignment - use plain text for printf, then colorize with sed
        printf "%-10s %-25s %-10s %-15s %-12s %s\n" "$proto" "$ip" "$port" "$state" "$pid" "$program" | \
        sed -E "s/^(tcp[^ ]*)/$(echo -e ${GREEN})\1$(echo -e ${NC})/" | \
        sed -E "s/^(udp[^ ]*)/$(echo -e ${BLUE})\1$(echo -e ${NC})/" | \
        sed -E "s/([0-9]+)( +LISTEN)/$(echo -e ${CYAN})\1$(echo -e ${NC})\2/" | \
        sed -E "s/([0-9]+)( +-)/$(echo -e ${CYAN})\1$(echo -e ${NC})\2/" | \
        sed -E "s/LISTEN/$(echo -e ${YELLOW})LISTEN$(echo -e ${NC})/" | \
        sed -E "s/ESTABLISHED/$(echo -e ${GREEN})ESTABLISHED$(echo -e ${NC})/"
    done
    
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo -e "\nğŸ’¡ Usage: port [search_term] | Examples: port nginx | ports 80\n"
}

# Show only listening ports (compact view)
portlistening() {
    local CYAN='\033[1;36m'
    local GREEN='\033[0;32m'
    local NC='\033[0m'
    
    echo -e "\nğŸ”Š LISTENING PORTS\n"
    printf "%-10s %-12s %-25s\n" "PROTO" "PORT" "PROGRAM"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    sudo netstat -tulpn 2>/dev/null | grep LISTEN | awk '{print $1, $4, $7}' | \
    while read proto addr pidprog; do
        port=$(echo "$addr" | rev | cut -d: -f1 | rev)
        prog=$(echo "$pidprog" | cut -d/ -f2-)
        printf "%-10s %-12s %-25s\n" "$proto" "$port" "$prog"
    done | sort -k2 -n | while IFS= read -r line; do
        echo "$line" | sed -E "s/^(tcp[^ ]*)/\\$(echo -e '\033[0;32m')\1\\$(echo -e '\033[0m')/" | \
        sed -E "s/([0-9]+)/\\$(echo -e '\033[1;36m')\1\\$(echo -e '\033[0m')/"
    done
    echo ""
}

#mark current directory as mm
mark(){
    dir=$PWD
    #sed -i  "5s|.*|\"$dir\"|g" ~/Desktop/a.txt 
    sed -i  "18s|.*|alias mm=\"cd $dir \&\& ranger \"|g" ~/.aliases 
    load_resource_rcfiles
}

findCommand() {
    local search_term="$1"
    
    if [ -z "$search_term" ]; then
        echo "Usage: findCommand <search_term>"
        return 1
    fi
    
    # Colors
    local BLUE='\033[1;34m'
    local GREEN='\033[1;32m'
    local YELLOW='\033[1;33m'
    local CYAN='\033[1;36m'
    local RESET='\033[0m'
    local DIM='\033[2m'
    
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${BLUE}â•‘${RESET}  Searching for: ${GREEN}$search_term${RESET}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""
    
    # 1. ALIASES
    local aliases=$(alias | grep -i "$search_term")
    if [ -n "$aliases" ]; then
        echo -e "${CYAN}â–¶ MATCHED ALIASES:${RESET}"
        echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo "$aliases" | while IFS= read -r line; do
            echo "  â€¢ $line"
        done
        echo ""
    fi
    
    # 2. FUNCTIONS (names only, clean list)
    local func_names=$(declare -F | awk '{print $3}' | while read func; do
        if declare -f "$func" | grep -qi "$search_term"; then
            echo "$func"
        fi
    done)
    
    if [ -n "$func_names" ]; then
        echo -e "${CYAN}â–¶ MATCHED FUNCTIONS:${RESET}"
        echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        echo "$func_names" | while IFS= read -r func; do
            echo "  â€¢ $func"
        done
        echo ""
    fi
    
    # 3. COMMENTS from .alias files
    echo -e "${CYAN}â–¶ MATCHED LINES WITH CONTEXT:${RESET}"
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    
    local found_any=false
    for file in ~/.alias*; do
        if [ -f "$file" ]; then
            local file_matches=$(grep -i -n -B 1 -A 1 "$search_term" "$file" 2>/dev/null)
            if [ -n "$file_matches" ]; then
                found_any=true
                local basename=$(basename "$file")
                echo -e "${YELLOW}ğŸ“ $basename${RESET}"
                
                echo "$file_matches" | while IFS= read -r line; do
                    if [[ "$line" == "--" ]]; then
                        echo ""
                    else
                        local line_num=$(echo "$line" | cut -d: -f1)
                        local content=$(echo "$line" | cut -d: -f2-)
                        
                        # Highlight comments
                        if [[ "$content" =~ ^[[:space:]]*# ]]; then
                            echo -e "   ${DIM}$line_num:${RESET} ${GREEN}$content${RESET}"
                        # Highlight the matching line
                        elif echo "$content" | grep -qi "$search_term"; then
                            echo -e "   ${DIM}$line_num:${RESET} ${YELLOW}$content${RESET}"
                        else
                            echo -e "   ${DIM}$line_num: $content${RESET}"
                        fi
                    fi
                done
                echo ""
            fi
        fi
    done
    
    if [ "$found_any" = false ]; then
        echo "  No matches found in .alias files"
        echo ""
    fi
    
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
}

#-------------------------------
# unzip unrar
#-------------------------------
alias unrarall='for file in *.rar; do unrar e -p "$file"; done'
alias unzipgarbled='unzip -O cp936 '  #unzip and solve garbled issue


look() {
    if [ $# -eq 0 ]; then
        echo "Please provide a domain name."
        return 1
    fi
    
    local domain="$1"
    
    # whois "$domain" | less
    whois "$domain" | \
    awk '/Creation Date/ {print "\033[31m" $0 "\033[0m"} {print}' | \
    less -R
}



#-------------------------------
# brightness
#-------------------------------
alias 1='sudo ddcutil setvcp 10 10 --display 1'
alias 5='sudo ddcutil setvcp 10 50 --display 1'
alias 9='sudo ddcutil setvcp 10 90 --display 1'

#-------------------------------
# sound volume
#-------------------------------
alias 11='amixer sset "Master" 10%'
alias 22='amixer sset "Master" 20%'
alias 33='amixer sset "Master" 30%'
alias 44='amixer sset "Master" 40%'
alias 55='amixer sset "Master" 50%'
alias 66='amixer sset "Master" 60%'
alias 77='amixer sset "Master" 70%'
alias 88='amixer sset "Master" 80%'
alias 99='amixer sset "Master" 90%'
alias 00='amixer sset "Master" 100%'
alias soundRestart='pulseaudio -k && sudo alsa force-reload'

#-------------------------------
# fzf
#-------------------------------
cdf() {
   cd ~
   local file
   local dir
   file=$(fzf +m -q "$1") && dir=$(dirname "$file") 
   cd "$dir"
   pwd
}


helpfzf() {
    local cmd="$1"
    shift
    local extra_args="$*"
    
    if ! command -v "$cmd" &> /dev/null; then
        echo "âŒ Command not found: $cmd"
        return 1
    fi
    
    if ! command -v fzf &> /dev/null; then
        echo "âŒ fzf not found. Install with: brew install fzf"
        return 1
    fi
    
    echo "ğŸ” Loading help for: $cmd (smart detection)"
    
    # Smart help detection - try all methods and pick the longest
    local help_content=""
    local help_source=""
    local best_length=0
    
    # Array of help methods to try
    local help_methods=(
        "--help"
        "-h"
        "help"
        "-help"
        "--usage"
        "-usage"
        "usage"
        "-?"
        "/?"
    )
    
    echo "ğŸ” Scanning help methods..."
    
    # Try each method and track the longest output
    for method in "${help_methods[@]}"; do
        local temp_help=""
        local temp_length=0
        
        # Try the help method with timeout to avoid hanging
        temp_help=$(timeout 5s "$cmd" "$method" 2>&1 || true)
        
        # Skip if it's clearly an error message
        if [[ -n "$temp_help" ]] && 
           [[ ! "$temp_help" =~ "unknown option" ]] && 
           [[ ! "$temp_help" =~ "invalid option" ]] && 
           [[ ! "$temp_help" =~ "unrecognized option" ]] &&
           [[ ! "$temp_help" =~ "illegal option" ]] &&
           [[ ! "$temp_help" =~ "bad option" ]] &&
           [[ ! "$temp_help" =~ "command not found" ]] &&
           [[ ! "$temp_help" =~ "No such file" ]]; then
            
            temp_length=${#temp_help}
            
            echo "   ğŸ“Š $method: ${temp_length} chars"
            
            # Keep track of the longest valid help output
            if [[ $temp_length -gt $best_length ]] && [[ $temp_length -gt 100 ]]; then
                help_content="$temp_help"
                help_source="$cmd $method"
                best_length=$temp_length
            fi
        else
            echo "   âŒ $method: failed or error"
        fi
    done
    
    # Try "cmd help" pattern (different from "cmd --help")
    echo "ğŸ” Trying 'help' as subcommand..."
    local help_subcmd=""
    help_subcmd=$(timeout 5s "$cmd" help 2>&1 || true)
    
    if [[ -n "$help_subcmd" ]] && 
       [[ ! "$help_subcmd" =~ "unknown" ]] && 
       [[ ! "$help_subcmd" =~ "invalid" ]] &&
       [[ ${#help_subcmd} -gt $best_length ]] &&
       [[ ${#help_subcmd} -gt 100 ]]; then
        help_content="$help_subcmd"
        help_source="$cmd help"
        best_length=${#help_subcmd}
        echo "   ğŸ“Š help subcommand: ${best_length} chars"
    fi
    
    # Try man page as fallback
    if [[ $best_length -lt 200 ]]; then
        echo "ğŸ” Trying man page..."
        if man "$cmd" >/dev/null 2>&1; then
            local man_content
            man_content=$(man "$cmd" 2>/dev/null)
            if [[ -n "$man_content" ]] && [[ ${#man_content} -gt $best_length ]]; then
                help_content="$man_content"
                help_source="man $cmd"
                best_length=${#man_content}
                echo "   ğŸ“Š man page: ${best_length} chars"
            fi
        else
            echo "   âŒ man page: not available"
        fi
    fi
    
    # Try running with no args as last resort
    if [[ $best_length -lt 100 ]]; then
        echo "ğŸ” Trying no arguments..."
        local no_args_help
        no_args_help=$(timeout 3s "$cmd" 2>&1 || true)
        if [[ -n "$no_args_help" ]] && [[ ${#no_args_help} -gt $best_length ]]; then
            help_content="$no_args_help"
            help_source="$cmd (no args)"
            best_length=${#no_args_help}
            echo "   ğŸ“Š no args: ${best_length} chars"
        fi
    fi
    
    # Special handling for certain command patterns
    case "$cmd" in
        "git"|"docker"|"kubectl"|"aws"|"gcloud")
            # These often have comprehensive help with specific patterns
            echo "ğŸ” Trying comprehensive help for $cmd..."
            local comprehensive_help=""
            
            case "$cmd" in
                "git")
                    comprehensive_help=$(git help 2>/dev/null || git --help 2>/dev/null || true)
                    ;;
                "docker")
                    comprehensive_help=$(docker help 2>/dev/null || docker --help 2>/dev/null || true)
                    ;;
                "kubectl")
                    comprehensive_help=$(kubectl help 2>/dev/null || kubectl --help 2>/dev/null || true)
                    ;;
                "aws")
                    comprehensive_help=$(aws help 2>/dev/null || aws --help 2>/dev/null || true)
                    ;;
                "gcloud")
                    comprehensive_help=$(gcloud help 2>/dev/null || gcloud --help 2>/dev/null || true)
                    ;;
            esac
            
            if [[ -n "$comprehensive_help" ]] && [[ ${#comprehensive_help} -gt $best_length ]]; then
                help_content="$comprehensive_help"
                help_source="$cmd (comprehensive)"
                best_length=${#comprehensive_help}
                echo "   ğŸ“Š comprehensive: ${best_length} chars"
            fi
            ;;
    esac
    
    # Final validation
    if [[ -z "$help_content" ]] || [[ $best_length -lt 50 ]]; then
        echo "âŒ No substantial help content found for $cmd"
        echo "ğŸ” Tried: ${help_methods[*]}, help subcommand, man page, no args"
        return 1
    fi
    
    echo "âœ… Best help source: $help_source (${best_length} characters)"
    echo ""
    
    # Parse help content to extract actionable items
    local temp_file=$(mktemp)
    
    {
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“š Best Help Source: $help_source"
        echo "ğŸ“Š Content Length: $best_length characters"
        echo "ğŸ¯ Command: $cmd"
        [[ -n "$extra_args" ]] && echo "ğŸ“ Extra Args: $extra_args"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        
        # Extract and categorize content
        echo "ğŸš€ QUICK ACTIONS:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        # Enhanced subcommand detection with multiple patterns
        local subcommands=""
        
        # Pattern 1: Standard "command description" format
        local pattern1
        pattern1=$(echo "$help_content" | \
            grep -E "^[[:space:]]*[a-z][a-z0-9_-]{2,}[[:space:]]+" | \
            grep -v "^[[:space:]]*-" | \
            awk '{print $1}' | \
            sort -u)
        
        # Pattern 2: Commands in "Available commands:" sections
        local pattern2
        pattern2=$(echo "$help_content" | \
            sed -n '/[Aa]vailable.*[Cc]ommands/,/^$/p' | \
            grep -E "^[[:space:]]*[a-z][a-z0-9_-]{2,}" | \
            awk '{print $1}' | \
            sort -u)
        
        # Pattern 3: Commands in "Commands:" sections
        local pattern3
        pattern3=$(echo "$help_content" | \
            sed -n '/^[[:space:]]*[Cc]ommands:/,/^$/p' | \
            grep -E "^[[:space:]]*[a-z][a-z0-9_-]{2,}" | \
            awk '{print $1}' | \
            sort -u)
        
        # Pattern 4: Indented commands (common in many CLIs)
        local pattern4
        pattern4=$(echo "$help_content" | \
            grep -E "^[[:space:]]{2,}[a-z][a-z0-9_-]{2,}[[:space:]]" | \
            awk '{print $1}' | \
            sort -u)
        
        # Combine all patterns and deduplicate
        subcommands=$(echo -e "$pattern1\n$pattern2\n$pattern3\n$pattern4" | \
            grep -v "^$" | \
            sort -u | \
            head -20)
        
        if [[ -n "$subcommands" ]]; then
            echo "$subcommands" | while IFS= read -r subcmd; do
                # Try to find description for this subcommand
                local desc=""
                
                # Look for description in various formats
                desc=$(echo "$help_content" | \
                    grep -E "^[[:space:]]*$subcmd[[:space:]]+" | \
                    head -1 | \
                    sed "s/^[[:space:]]*$subcmd[[:space:]]*//" | \
                    cut -c1-70)
                
                # If no description found, try other patterns
                if [[ -z "$desc" || "$desc" == "$subcmd" ]]; then
                    desc=$(echo "$help_content" | \
                        grep -E "[[:space:]]$subcmd[[:space:]]" | \
                        head -1 | \
                        sed "s/.*$subcmd[[:space:]]*//" | \
                        cut -c1-70)
                fi
                
                # Fallback to generic description
                [[ -z "$desc" ]] && desc="Available subcommand"
                
                printf "â–¶ï¸  RUN: %-15s â”‚ %s\n" "$subcmd" "$desc"
            done
            echo ""
        else
            echo "No subcommands detected"
            echo ""
        fi
        
        # Enhanced option detection
        echo "âš™ï¸  COMMON OPTIONS:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        # Look for options in multiple formats
        local options
        options=$(echo "$help_content" | \
            grep -E "^[[:space:]]*(-[a-zA-Z]|--[a-zA-Z])" | \
            head -15)
        
        if [[ -n "$options" ]]; then
            echo "$options" | while IFS= read -r line; do
                local option=$(echo "$line" | awk '{print $1}')
                local desc=$(echo "$line" | sed 's/^[[:space:]]*[^[:space:]]*[[:space:]]*//' | cut -c1-65)
                printf "ğŸ”§ USE: %-20s â”‚ %s\n" "$option" "$desc"
            done
        else
            echo "No standard options found"
        fi
        echo ""
        
        # Enhanced usage pattern detection
        echo "ğŸ“– USAGE PATTERNS:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        local usage_patterns
        usage_patterns=$(echo "$help_content" | \
            grep -i -E "(usage|synopsis|example):" -A 5 | \
            grep -v "^--$" | \
            head -10)
        
        if [[ -n "$usage_patterns" ]]; then
            echo "$usage_patterns" | sed 's/^[[:space:]]*/ğŸ“‹ /'
        else
            echo "ğŸ“‹ No usage patterns found"
        fi
        echo ""
        
        echo "ğŸ“„ FULL HELP CONTENT:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "$help_content"
        
    } > "$temp_file"
    
    # Use fzf with the same interface as before
    echo "ğŸ® Navigation: j/k (move) | type to search | Tab (preview) | Esc (exit)"
    echo ""
    
    local selection
    selection=$(cat "$temp_file" | \
        fzf --ansi \
            --height=90% \
            --layout=reverse \
            --border \
            --prompt="ğŸ” $cmd (${best_length} chars) â¯ " \
            --header="Smart help detection active â”‚ j/k: navigate â”‚ type: search â”‚ Tab: preview" \
            --preview-window="right:50%" \
            --preview="echo 'Selected: {}' | fold -w 45" \
            --bind="j:down" \
            --bind="k:up" \
            --bind="ctrl-d:half-page-down" \
            --bind="ctrl-u:half-page-up" \
            --bind="tab:toggle-preview" \
            --bind="ctrl-y:execute-silent(echo {} | pbcopy)" \
            --bind="esc:abort" \
            --bind="enter:accept" \
    )
    
    # Clean up temp file
    rm -f "$temp_file"
    
    # Process the selection (same logic as before)
    if [[ -n "$selection" ]]; then
        if [[ "$selection" =~ ^â–¶ï¸[[:space:]]*RUN:[[:space:]]*([^[:space:]â”‚]+) ]]; then
            local subcmd="${BASH_REMATCH[1]}"
            local full_command="$cmd $subcmd $extra_args"
            
            echo ""
            echo "ğŸš€ Detected subcommand: $subcmd"
            echo -n "ğŸ’¬ Additional arguments for '$cmd $subcmd': "
            read -e -r additional_args
            
            [[ -n "$additional_args" ]] && full_command="$cmd $subcmd $additional_args $extra_args"
            
            echo ""
            echo "ğŸ”¥ Running: $full_command"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            
            # Safety check for destructive commands
            case "$cmd $subcmd" in
                *"rm "*|*"delete "*|*"destroy "*|*"drop "*|*"remove "*)
                    echo "âš ï¸  This command might be destructive!"
                    echo -n "Are you sure? [y/N]: "
                    read -r confirm
                    [[ "$confirm" != "y" && "$confirm" != "Y" ]] && return 0
                    ;;
            esac
            
            eval "$full_command"
            
        elif [[ "$selection" =~ ^ğŸ”§[[:space:]]*USE:[[:space:]]*([^[:space:]â”‚]+) ]]; then
            local option="${BASH_REMATCH[1]}"
            local full_command="$cmd $option $extra_args"
            
            echo ""
            echo "ğŸ”§ Selected option: $option"
            echo -n "â¯ Additional arguments: "
            read -e -r additional_args
            
            [[ -n "$additional_args" ]] && full_command="$cmd $option $additional_args $extra_args"
            
            echo ""
            echo "ğŸ”¥ Running: $full_command"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            eval "$full_command"
            
        else
            echo ""
            echo "ğŸ“‹ Selected:"
            echo "$selection"
            echo ""
            echo "ğŸ’¡ To run commands, select lines starting with â–¶ï¸  or ğŸ”§"
        fi
    fi
}


#-------------------------------
# chrome
#-------------------------------
updateChrome(){
   cd $HOME
   wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
   sudo dpkg -i google-chrome-stable_current_amd64.deb
   rm google-chrome-stable_current_amd64.deb
}

#-------------------------------
# file formatting
#-------------------------------
# covert all pdf to text file in the current folder/directory
alias convertallpdf='ls *.pdf | xargs -n1 pdftotext'
# covert all pdf to png file in the current folder/directory
alias convertallpdftopng=allpdftopng
function allpdftopng(){

	for file in *.pdf;
		do pdftoppm "$file" "$file";
	done
}
# convert ppt to pdf
alias convertpptxtopdf='libreoffice --headless --invisible --convert-to pdf *.pptx'
# convert doc/docx to text
alias convertdocxtotxt='libreoffice --headless --convert-to txt'
# convert images to pdf
alias convertjpgtopdf='convert *.jpg output.pdf'

# convert markdown to pdf
md2pdf_batch() {
    local tmp_css="__temp_style.css"

    # Write the CSS content into a temp file
    cat > "$tmp_css" <<'EOF'
body {
  margin: 5mm;
  font-family: sans-serif;
}
pre {
  background-color: #eaeaea;
  color: #000000;
  padding: 10px;
  border-radius: 4px;
  overflow-x: auto;
  border: 1px solid #cccccc;
}
code {
  font-family: monospace;
}
code span.kw { font-weight: bold; }
code span.st { font-style: italic; }
code span.co { color: #555555; }
code span.fu { text-decoration: underline; }
h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
table { border-collapse: collapse; }
table, th, td { border: 1px solid #ccc; padding: 4px; }
EOF

    for f in *.md; do
        [[ -f "$f" ]] || continue
        echo "Converting $f â†’ ${f%.md}.pdf"
        pandoc "$f" -o "${f%.md}.pdf" \
            --pdf-engine=wkhtmltopdf \
            -V margin-top=5mm \
            -V margin-bottom=5mm \
            -V margin-left=5mm \
            -V margin-right=5mm \
            --css="$tmp_css" \
            --pdf-engine-opt=--enable-local-file-access
    done

    # Remove temporary CSS file
    rm -f "$tmp_css"
    echo "âœ… All Markdown files converted."
}

#---------------------
# applications
#---------------------
#list all app installed manually
alias installed=manually_installed
function manually_installed(){
	comm -23 <(apt-mark showmanual | sort -u) <(gzip -dc /var/log/installer/initial-status.gz | sed -n 's/^Package: //p' | sort -u)
}

#update and upgrade packages
alias update=updateall
function updateall(){
	sudo apt upgrade;
	sudo apt-get upgrade;
	sudo apt update;
	sudo apt-get update;
  updateChrome;
  sudo snap refresh;
  python3 -m pip install -U yt-dlp;
	sudo apt-get clean;
	sudo apt clean;
	sudo apt autoremove;
	sudo apt-get autoremove;
	sudo apt-get autoclean;
	sudo apt autoclean;
}

function clean(){
	sudo apt-get clean;
	sudo apt clean;
	sudo apt autoremove;
	sudo apt-get autoremove;
	sudo apt-get autoclean;
	sudo apt autoclean;
}


##########################
#  youtube-dl
##########################

#alias youtubedownloadmp3='youtube-dl -xiwc --audio-format mp3 '
#alias youtube='youtube-dl -o "%(title)s.%(ext)s"'
alias youtubesubtitle='youtube-dl --sub-lang en --convert-subs srt --write-sub'

##########################
#  mpv
###########################
alias mp3='mpv --no-video '

##########################
#  yt-dlp
###########################
alias youtubedownloadmp3='youtube -xiwc --audio-format mp3 '
alias youtube='yt-dlp -o "%(title)s.%(ext)s"'
alias youtubechannelrelease='yt-dlp -x --audio-format mp3 -o "%(uploader)s/[%(upload_date>%Y)s] %(album,playlist_title)s/%(track_number,playlist_index)02d - %(title)s.%(ext)s" --add-metadata --embed-thumbnail --yes-playlist '
alias youtubeplayliststartfrom='_ytplv() { yt-dlp -o "%(uploader)s/[%(upload_date>%Y)s] %(playlist_title)s/%(playlist_index)02d - %(title)s.%(ext)s" --add-metadata --embed-thumbnail --write-info-json --yes-playlist --playlist-start "$1" "$2"; }; _ytplv'

# load all source files
load() {
  source ~/.bashrc
  source ~/.profile
  [ -n "$TMUX" ] && tmux source-file ~/.tmux.conf
  echo "dotfiles reloaded..."
  echo "to reload awesomeWM, use following command"
  echo "super+ctrl+r"
}

#########################
#   tmux
#########################
# open tmux fullscreen with sessions attached
alias tnew=createNewSessionInsideTmuxSession

function createNewSessionInsideTmuxSession(){
session_name=$1
# 1. First you check if a tmux session exists with a given name.
tmux has-session -t=$session_name 2> /dev/null
# 2. Create the session if it doesn't exists.
if [[ $? -ne 0 ]]; then
  TMUX='' tmux new-session -d -s "$session_name"
fi
# 3. Attach if outside of tmux, switch if you're in tmux.
if [[ -z "$TMUX" ]]; then
  tmux attach -t "$session_name"
else
  tmux switch-client -t "$session_name"
fi
}


alias tkill=killTmuxSession 
function killTmuxSession(){
  tls;
  IFS= read -r -p "input session name: " sessionName
  tmux switch-client -t main && #switch to main session before target session killed
  tmux kill-session -t "$sessionName" ;
}

#main session layout
alias layout=defaultLayout
function defaultLayout(){
  tmux selectp -t 0;
  tmux splitw -v -p 40;  #split vertically
  tmux splitw -h -p 50;
  tmux splitw -v -p 50;
  tmux selectp -t 1;     #select pane number 1
  tmux splitw -v -p 50;
  tmux send-keys -t2 music Enter ;
  tmux send-keys -t2 ranger Enter ;
  tmux send-keys -t4 "cd ~/Downloads" Enter ;
  tmux selectp -t 0;
}

#project session layout
alias project=projectLayout
function projectLayout(){
  tmux selectp -t 0;
  tmux splitw -v -p 60;  #split vertically
  tmux splitw -h -p 50;
  tmux selectp -t 0;
}

#create new window
alias tnewwindow='tmux new-window -n ' 
#rename the current window
alias twindowname='tmux rename-window '
#list all session and windows
alias l='tmux choose-window '

#----------------------------
# application github
#----------------------------
alias lifeike='cd /home/feeco/Documents/feeco && gb && gs && ranger'
alias gb='git branch --sort=committerdate | column'

alias pull=pullAllBranches
pullAllBranches() {
    local current_branch=$(git branch --show-current)
    local failed_branches=()
    local conflict_branches=()
    
    echo "ğŸ”„ Fetching latest changes from all remotes..."
    git fetch --all
    echo ""
    
    for branch in $(git branch --format="%(refname:short)"); do
        echo "ğŸ“ Processing branch: $branch"
        
        # Check if branch has upstream
        local upstream=$(git rev-parse --abbrev-ref "$branch@{upstream}" 2>/dev/null)
        
        if [ -z "$upstream" ]; then
            echo "   âš ï¸  No upstream configured, skipping"
            echo ""
            continue
        fi
        
        # Switch to branch
        if ! git checkout "$branch" 2>/dev/null; then
            echo "   âŒ Failed to checkout, skipping"
            failed_branches+=("$branch")
            echo ""
            continue
        fi
        
        # Try to merge
        if git merge "$upstream" --no-edit; then
            echo "   âœ… Successfully updated $branch"
        else
            echo ""
            echo "   âŒ MERGE CONFLICT DETECTED"
            conflict_branches+=("$branch")
            
            # Abort the merge
            git merge --abort
            echo "   ğŸ”™ Merge aborted, branch unchanged"
        fi
        echo ""
    done
    
    # Return to original branch
    git checkout "$current_branch" 2>/dev/null
    
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    if [ ${#conflict_branches[@]} -eq 0 ] && [ ${#failed_branches[@]} -eq 0 ]; then
        echo "ğŸ‰ All branches updated successfully!"
    else
        echo "âš ï¸  Update completed with issues:"
        echo ""
        
        if [ ${#conflict_branches[@]} -gt 0 ]; then
            echo "   Branches with conflicts (not updated):"
            for b in "${conflict_branches[@]}"; do
                echo "   â€¢ $b"
            done
            echo ""
        fi
        
        if [ ${#failed_branches[@]} -gt 0 ]; then
            echo "   Branches that failed to checkout:"
            for b in "${failed_branches[@]}"; do
                echo "   â€¢ $b"
            done
            echo ""
        fi
        
        echo "   ğŸ’¡ To resolve conflicts manually:"
        echo "   1. git checkout <branch-name>"
        echo "   2. git merge origin/<branch-name>"
        echo "   3. Resolve conflicts and commit"
    fi
    
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ“ You are on branch: $current_branch"
}

alias gitlastcommit='git diff HEAD^ '
alias gitcommitscount='git shortlog -sn --all'
alias gitlistconflicts='git diff --check'
alias gittodolist='gh issue list'
alias gittodo='gh issue create'

# git status
gs() {
  echo "== Current Branch : $(git branch --show-current)=========================="
  while IFS= read -r line; do
    status="${line:0:2}"
    file="${line:3}"
    case "$status" in
      " M") echo -e "\033[36m$line\033[0m" ;;  # Cyan for Modified
      "A ") echo -e "\033[32m$line\033[0m" ;;  # Green for Added
      " D") echo -e "\033[34m$line\033[0m" ;;  # Red for Deleted
      "??") echo -e "\033[33m$line\033[0m" ;;  # Yellow for Untracked
      *) echo "$line" ;;
    esac
  done < <(git status --short)
  echo "== Current Directory : $(basename "$PWD")====================================="
}

#git tags
alias gt='echo "local tags: " && git tag -n && echo "" && echo "" && echo "remote tags: " && git ls-remote --tags'
alias gnewtag='git tag -a' #append the tag name after

#list all conflict files
alias gitconflict='git diff --name-only --diff-filter=U'
#alias gl='git log -20 --abbrev-commit --pretty=oneline --graph'
alias gl='git log -20 --graph --abbrev-commit --decorate=no --date=format:"%m-%d %H:%M" --format=format:"%C(03)%>|(15)%h%C(reset)  %an%C(reset) %C(04)%ad%C(reset)  %s%C(reset)  %C(bold 1)%d%C(reset) %C(reset)" --all'
alias gitbigfile='git rev-list --all | xargs -rL1 git ls-tree -r --long | sort -uk3 | sort -rnk4 | head -10'
# git discard all local changes and remove all untracked files(new files)
alias gr='git reset --hard && git clean -fd'

# open a git project then open source code in vscode then run this project
alias open=git-open-project
function git-open-project(){
    git-clone-all-branches $1 && code -r . && npm install &&  npm run start
}

# Map GitHub usernames to SSH aliases (from ~/.ssh/config)
declare -A GH_ALIAS_MAP=(
    [hankAndfeeco]=hankAndfeeco
    [lifeike]=lifeike
)

# clone a git repo with all remote branches
gc() {
    if [ $# -eq 0 ]; then
        echo "Usage: gc <repository-url> [directory-name]"
        return 1
    fi
    
    local repo_url="$1"
    local dir_name="${2:-$(basename "$repo_url" .git)}"
    
    git clone "$repo_url" "$dir_name"
    cd "$dir_name"
    
    # Fetch all remote branches and create local tracking branches
    for branch in $(git branch -r | grep -v HEAD | sed 's/origin\///'); do
        git checkout -b "$branch" "origin/$branch" 2>/dev/null || true
    done
    
    # Switch back to main/master branch
    git checkout main 2>/dev/null || git checkout master 2>/dev/null
}


alias gp='pushall'
function pushall(){
    #read -p 'commit message: ' commitMessage
    IFS= read -r -p "commit message: " commitMessage
    git add -A;
    git commit --allow-empty -am "$commitMessage";
    branch=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
    git push -u origin $branch
    clear
}

# git deploy 
function gitdeploy(){
   git checkout main
   git merge staging
   git push origin main
   git checkout staging
}

# github account gh 
alias githublogin='gh auth login'
alias githublist='gh auth status'
alias githubswitch='gh auth switch'
alias githubrepos='gh repo list'
alias githubclonerepo='gh repo clone '
alias githubbrowser='gh browse'

#-----------------
# npm + mongodb
#-----------------
alias npminstalled='npm list --global --depth=0'

#-----------------
# ffmpeg
#-----------------
# merge video with subtitles
alias combinevideosubtitle=combine_video_and_subtitles
function combine_video_and_subtitles(){

    ffmpeg -i $1 -i $2 -c:s mov_text -c:v copy -c:a copy output.mp4

}

# split video into 10 mins clip
# ffmpeg -i fff.avi -acodec copy -f segment -segment_time 10 -vcodec copy -reset_timestamps 1 -map 0 fff%d.avi
alias splitvideo='split_big_video_into_clips_of_10mins'
function split_big_video_into_clips_of_10mins(){
	local input=$1;
	ffmpeg -i $1 -acodec copy -f segment -segment_time 600 -vcodec copy -reset_timestamps 1 -map 0 $1%d.avi
}

#-----------------
# chezmoi
#-----------------
alias update-dotfiles='chezmoi re-add'
alias sync-dotfiles='cd ~/Desktop && chezmoi update'
alias cd-dotfiles='cd ~/.local/share/chezmoi && ranger'
alias add-dotfiles='chezmoi add'
alias cs='chezmoi status'

##########################
#  node prisma
###########################
function updatePrismaSchema(){
 npx prisma db pull
 npx prisma generate
}


#------------------------------------
# postgresql database running locally
#------------------------------------
# PostgreSQL Alias Cheatsheet (MongoDB-like Syntax)
# Database & Connection
alias showdbs='psql -c "\l"'                    #	\l	List all databases
alias usedb='psql -d '                          #	\c  dbname	Switch database
alias currentdb='psql -c "\conninfo"'	          # \conninfo	Show current DB connection
# Tables & Schemas
alias showtables='psql -c "\dt"'	              # \dt	List tables in current DB
alias showalltables='psql -c "\dt *.*"'	        # \dt *.*	List all tables (including system schemas)
alias desc='psql -c "\d+"'	                    # \d+ table	Describe a table (structure, indexes, etc.)
# User & Roles
alias showusers='psql -c "\du"'	                # \du	List all users/roles
alias showgrants='psql -c "\dp"'                #	\dp	Show table permissions
# Query & Admin Shortcuts
alias query='psql -c'	                          # SELECT ...	Run a quick SQL query
alias explain='psql -c "EXPLAIN ANALYZE"'	      # EXPLAIN ANALYZE ...	Analyze query performance
alias killconn='psql -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE ..."'	   # pg_terminate_backend()	Kill a stuck connection
# Export & Import
alias exportdb='pg_dump -U user -d dbname -f output.sql'	# pg_dump	Export DB to SQL file
alias importdb='psql -U user -d dbname -f input.sql'	# psql -f	Import SQL file into DB



#------------------------------------
# tts
#------------------------------------
tts() {
    edge-tts --voice zh-CN-YunyangNeural --rate=-10% --file "$1" --write-media "${1%.*}.mp3"
}


#------------------------------------
# disk / system
#------------------------------------
diskreport() {
  # Colors
  RED="\e[31m"
  GREEN="\e[32m"
  CYAN="\e[36m"
  YELLOW="\e[33m"
  BOLD="\e[1m"
  RESET="\e[0m"

  echo -e "${BOLD}${CYAN}=== ğŸ” Disk and OS Information Report ===${RESET}\n"

  # 1. Show physical block devices only
  echo -e "${YELLOW}ğŸ‘‰ Physical Disks and Partitions:${RESET}"
  lsblk -o NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT,TYPE \
    | grep -E "disk|part" \
    | grep -v "loop"
  echo

  # 2. Show detailed partition info
  echo -e "${YELLOW}ğŸ‘‰ Detailed Partition Layout (fdisk):${RESET}"
  sudo fdisk -l | grep -E "Disk /dev/(sd|nvme)"
  echo

  # 3. Show mounted filesystems (only real devices)
  echo -e "${YELLOW}ğŸ‘‰ Currently Mounted Filesystems:${RESET}"
  mount | grep '^/dev/' | grep -v "loop"
  echo

  # 4. Show UEFI boot entries
  echo -e "${YELLOW}ğŸ‘‰ UEFI Boot Entries (Bootloaders in firmware):${RESET}"
  sudo efibootmgr -v
  echo

  # 5. Show Linux distribution info
  echo -e "${YELLOW}ğŸ‘‰ Current Linux Distribution:${RESET}"
  grep -E 'PRETTY_NAME|VERSION=' /etc/os-release
  echo

  # 6. Show kernel and architecture
  echo -e "${YELLOW}ğŸ‘‰ Kernel and System Architecture:${RESET}"
  uname -a
  echo

  # 7. Check for Windows partitions (NTFS)
  echo -e "${YELLOW}ğŸ‘‰ Checking for Windows Partitions (NTFS):${RESET}"
  lsblk -o NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT,TYPE \
    | grep ntfs || echo -e "${RED}No Windows partitions found.${RESET}"
  echo

  echo -e "${GREEN}${BOLD}=== âœ… Report Complete ===${RESET}"
}

burnWindowUSB(){
  echo '1. run "diskrepot" command and find the mounted usb device, usually /dev/sda or /dev/sdb'
  echo "2. install woeusb"
  echo '3. sudo woeusb --target-filesystem NTFS --device "path/to/windows.iso" "/dev/sdX"'
  echo "4. takes about 1-2 hours to burn to usb"
}

burnLinuxUSB(){
  echo '1. run "diskrepot" command and find the mounted usb device, usually /dev/sda or /dev/sdb'
  echo '2. sudo dd if=linux.iso of=/dev/sdb bs=4M status=progress oflag=sync'
  echo "3. takes about 1-2 hours to burn to usb"
}
